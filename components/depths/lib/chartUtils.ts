export function formatNumber(value: number): string { return new Intl.NumberFormat(undefined,{maximumFractionDigits:2}).format(value); }
export function formatPercent(value: number, fractionDigits: number = 1): string {
   const v = value * 100;
   return `${v.toFixed(fractionDigits)}%`;
}
export function formatDurationMs(ms: number): string { if(ms<1000) return `${ms} ms`; const s=ms/1000; if(s<60) return `${s.toFixed(2)} s`; const m=Math.floor(s/60); const rs=(s%60).toFixed(0); return `${m}m ${rs}s`; }
export function getColorPalette(countOrKeys: string[]|number): string[] { const base=['#4f46e5','#10b981','#f59e0b','#ef4444','#8b5cf6','#06b6d4','#22c55e','#eab308','#f97316','#a855f7']; const n=Array.isArray(countOrKeys)?countOrKeys.length:countOrKeys; const out: string[]=[]; for(let i=0;i<n;i++) out.push(base[i%base.length]); return out; }
export function toRechartsTimeSeries(series: Array<{ key: string; points: Array<{ t: number; v: number }> }>): Array<Record<string, number>> { const map=new Map<number,Record<string,number>>(); for(const s of series){ for(const p of s.points){ const row=map.get(p.t)||{t:p.t}; row[s.key]=p.v; map.set(p.t,row); } } return Array.from(map.values()).sort((a,b)=>Number(a.t)-Number(b.t)); }
export function toBandComposed(series: Array<{ key: string; points: Array<{ t: number; mean?: number; min?: number; max?: number; p50?: number; p95?: number; p99?: number }> }>, mode: 'minmax'|'p50p95'|'p95p99'='p50p95'): Array<Record<string, number>> { const map=new Map<number,Record<string,number>>(); for(const s of series){ for(const p of s.points){ const row=map.get(p.t)||{t:p.t}; const lower=mode==='minmax'?(p.min??p.mean??0):mode==='p50p95'?(p.p50??p.mean??0):(p.p95??p.mean??0); const upper=mode==='minmax'?(p.max??p.mean??0):mode==='p50p95'?(p.p95??p.mean??0):(p.p99??p.mean??0); const band=Math.max(upper-(lower||0),0); if(typeof p.mean==='number') row['mean'] = p.mean; row[`lower`] = lower||0; row[`band`] = band; map.set(p.t,row); } } return Array.from(map.values()).sort((a,b)=>Number(a.t)-Number(b.t)); }
export function clampBins(bins: number[], min?: number, max?: number): number[] { const lo=min??Math.min(...bins); const hi=max??Math.max(...bins); return bins.map(b=>Math.min(Math.max(b,lo),hi)); }